\chapter{Estudio de las herramientas e infraestructuras disponibles}
\label{cap:estudio}

[Revisar]\\

En este capítulo se aborda el estudio de las distintas herramientas e infraestructuras de interés para la realización del proyecto.


\section{Elección de la herramienta de virtualización \emph{hardware}}

A la hora de hacer una virtualización \emph{hardware} hay varias opciones entre las que elegir. Las más ampliamente usadas son Xen y KVM. La principal diferencia entre ambas es que Xen ofrece paravirtualización y KVM ofrece virtualización nativa.
La paravirtualización presenta a las máquinas virtuales una interfaz que es similar, pero no idéntica, al hardware de la máquina física en la que se aloja. Todas las llamadas con privilegios deben ser capturadas y traducidas a llamadas al hipervisor. El sistema operativo de la máquina virtual debe ser modificado para hacer estas capturas.

[Figuras, figuras, figuras]

La virtualización nativa permite hacer una virtualización \emph{hardware} completa de manera eficiente. No requiere de ninguna modificación en el sistema operativo de la máquina virtual, pero necesita de un procesador con soporte para virtualización. KVM está incluido como un módulo del núcleo de Linux desde su versión 2.6.20, así que viene incluido por defecto en el sistema operativo de las máquinas del laboratorio.

Como los ordenadores del laboratorio poseen procesadores con extensiones de soporte para virtualización se eligió KVM para dar soporte a las máquinas virtuales. Esto significa que podemos usar cualquier sistema operativo, sin hacer ninguna modificación, para las máquinas virtuales.


\section{Análisis de las infraestructuras de ejecución de trabajos distribuidos}

%%% Revisar
[Revisar]
AppScale es una implementación \emph{open source} del App Engine de Google. Al igual que App Engine, AppScale permite alojar aplicaciones web; a diferencia de App Engine, las aplicaciones no serán alojadas en la infraestructura que Google posee, sino que serán alojadas en una infraestructura que el usuario posea. Además de permitir alojar aplicaciones web AppScale también ofrece las APIs de MapReduce y Neptune. La API de MapReduce permite escribir aplicaciones que hagan uso del \emph{framework} MapReduce. La API de Neptune añade a App Engine la capacidad de usar los nodos de la infraestructura para ejecutar trabajos. Los trabajos más representativos que puede ejecutar son: de entrada, de salida y MPI, aunque también se pueden ejecutar trabajos UPC (\emph{Berkeley UPC - Unified Parallel C}), X10, R y Go. Esta capacidad de ejecutar trabajos en la nube convierte a AppScale en una aplicación muy interesante.

%%% Revisar
[Revisar]
La otra infraestructura de ejecución de trabajos distribuidos que se ha elegido ha sido Torque. Torque entra en la categoría de las infraestructuras clásicas de ejecución de trabajos. Comprobar que el concepto de gestión de infraestructuras distribuidas podía aplicarse a una infraestructura de ejecución de trabajos ya establecida también era algo interesante, y Torque era un candidato idóneo para ello.


\section{Elección de la herramienta de gestión de configuración}

Dentro de las herramientas de gestión de configuración, se estudió el uso de CFEngine y Puppet. CFEngine es una herramienta de configuración con un lenguaje declarativo en el que se especifican acciones a realizar para las clases. Está programado en el lenguaje C y ofrece un buen rendimiento y un control detallado de cómo se hacen las cosas. Puppet es una herramienta con un lenguaje declarativo en el que se especifica cuál debe ser el estado de los elementos a configurar. A diferencia de CFEngine, Puppet posee un nivel mayor de abstracción que permite un mejor modelado de los recursos de un sistema. Por ejemplo, Puppet proporciona tipos para modelar usuarios, grupos, archivos, paquetes y servicios. Está programado en el lenguaje Ruby.

A la hora de realizar una extensión de la funcionalidad, se pensó que sería más fácil hacerla en la herramienta que más abstracción proporcionase y en el lenguaje en el que más fácil fuera modelar esta extensión. Por estas razones se eligió Puppet como la herramienta de gestión de configuración sobre la que hacer la extensión.


\section{Extensión de la herramientas de configuración elegida}

Una vez escogida la herramienta sobre la que se haría la extensión, quedaba por determinar cómo realizarla.

La primera opción que se barajó fue la de usar \emph{Faces} de Puppet. \emph{Faces} es una API (\emph{Application Programming Interface}) para crear subcomandos y acciones dentro de Puppet. Analizada a fondo, esta API no proporcionaba una ventaja muy superior a la ejecución de comandos desde la consola del sistema operativo, y no interesaba crear una abstracción que facilitara el trabajo para posteriormente estar usando continuamente la línea de comandos.

La segunda opción que se barajó fue la de la creación de un tipo y un proveedor para ese tipo. Esta opción sí que presenta una ventaja considerable: podemos usar el tipo para modelar la infraestructura distribuida y podemos usar el proveedor para indicar cómo iniciar y mantener esa infraestructura. Esta aproximación se acerca más al modelo que usa Puppet, ya que definimos la infraestructura como si fuera un recurso más de los que posee Puppet. Así pues, esta es la aproximación que se tomó para realizar la extensión.
